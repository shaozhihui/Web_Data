#### js的基本数据类型

boolen，number，string，underfind，null，symbol
引用数据类型array，date，obj



#### 堆和栈的区别

堆和栈的概念存在于数据结构和操作系统里面


在操作系统中，内存被分为栈区和堆区

在数据结构中， 栈中数据先进后出，而堆是一个优先队列
栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等
堆区一般是程序员分配释放，如果程序员不释放，结束时可能由垃圾回收机制回收



#### js有那些内置对象

1. 值属性这些全局返回一个简单值，这些值没有自己的属性和方法
   如同null，underfind等字变量

2. 函数属性，全局函数可以调用，不需要调用所属对象

3. 基本对象，基本对象包涵一般对象等

4. 数字和日期对象，用来表示数字，日期，和执行数字计算的对象number，math，date

   

#### null和underfind的区别

首先null和underfind都是基本数据类型
underfind是未定义，null是空，一般变量声明可还没有定义的都会返回underfind，null主要用在赋值一些可以返回的
变量用作初始化



#### js的原型链原型

js我们是使用构造函数来创建一个新对象，每个构造函数内部都有一个prototype属性，这个值属性是一个对象，这个对象
包涵了prtotype的所有实例对象和原型对象，当我们需要用到这个原型对象的某个属性值的时候，一般会先去实例对象寻找，
如果实例对象没有就会去原型对象找，这个原型对象又有自己的原型，这就是原型链。原型链接有继承和多态的性质



#### js获取原型的方法

obj.getprototpreof
P._prototype_



#### 7,type of NaN

number   因为nan是一个特殊值



#### array构造函数的只有一个参数的表现

array构造函数只带一个数字，该参数会被作为数组的预设长度，而非充当数组的一个元素，这样只会是一个空数组



#### {}和[]的value of和tostring的结果是什么

{}的value of是{}，tostring是objobj
[]的value of是[]，tostring是""



#### == 操作符的强制类型转换

字符串和数字之间的相等比较，是将字符串转化成数字在进行比较

null和undefind之间的比较是比较为真比较



#### 如何将字符串转化成数字 "12.3b"

如果字符串都不包含违法数字用number



#### 如何将浮点左边每三位数组添加一个都喊

function  aa(number){
	return  number.tolocalstring("en")
}



#### 生成随机数的方法

math.random（）*100



#### js创建对象的几种方式

构造函数模式，
原型链，
寄生方式寄生

function new(){
	 let data={}
let cons=[].shift.call(arguments)
data.__proto__=cons.prototype
let res=cons.allly(data,arguments)
rerturn type of res === "onject"?res:obj
		
}



#### js的作用域链.

作用域链是保证对执行环境的有权访问的所有变量和函数的有序访问，用过作用域链，我们可以方位
外部环境的变量和函数



#### this指向的问题

1，可以使用函数调用模式，this指向全局对象
2，方法调用，当一个函数作为一个对象的调用是，this指向这个对象
3，构造器调用模式，使用new，函数会创建一个对象，this指向这个新创建的对象
4，apply，call和bind调用模式来改变this指向

箭头函数也是通过这种方式来改变



#### dom和bom一个是浏览器对象

dom是指文档对象，他是指吧文档当成一个对象来对待

bom是指浏览器对象



#### 事件是什么如何阻止冒泡

事件是指用户操作网页的交互动作，比如click和move，事件除了用户触发也可以是文档加载，窗口都弄到那个大小调整

阻止事件冒泡event.stoppropagtion



#### 事件委托的原理

本质上是通过事件冒泡的原理，因为冒泡过程中，父节点可以通过事件对象捕获到
因此，我们把字节点的监听函数定义到副节点上，由父节点统一处理
使用事件代理我们不必要为每一个子元素绑定事件这样可以减少内存的消耗，并且我们可以实现动态
绑定



#### 什么是闭包

闭包是指有权访问另外一个函数作用域名中的变量的函数
，创建闭包最常见是就是函数内创建函数，创建的函数可以访问当强的函数
我们可以在外部调用闭包函数来创建私有变量

或者我们使用已经运行结束的函数创建上下文留在内存中，因为比好保留了这个函数不会被垃圾回收机制回收



#### 如果判断某个对象是否数据某个类

instanceif 来判断当前prototype是否出现在原型链的某个位置



#### 模块化开发

一个模块是实现一个特性功能的方法，最开始的时候js只有一些简单地功能，并没有模块的概念
随着程序越来越复杂，模块化开发的功能越来越重要

由于函数有单独作用域，最开始是使用函数来作为模块，几个函数作为一个模块，但是这样容易全局污染
，并且没有联系
后面提出来对象写法，讲函数作为一个对象来实现，这样会暴露所有模块，而且外部模块也能修改内部模块。



#### 缓存机制

分为强缓存和协议缓存

强缓存是如果资源有效则直接使用资源不必发送请求

而协议缓存会带一个请求头在发送请求会进行对比然后跟



#### 同步和异步的区别

同步可以理解为在执行一个函数的时候一直处于等待消息，这时候是堵塞的只有接受到消息才会往下执行消息

异步相当与执行函数的之后，不必堵塞等这返回值或者消息，只需要向系统发送一个异步请求，当系统接受到返回值是会自动出触发



#### 变量提升和let，const

变量提升的表现是无论在任何位置声明的变量，都被提升到函数的首部，我们可以在变量声明前调用而不会报错



#### 内存泄漏

闭包，没有声明的全局对象，计时器



####  this=== ”window“ ?"xx":"node"



#### 事件循环

event loop 就是宏任务和微任务

宏任务代表 settime 和setinterl  script脚本
微任务 new promise异步

当一个函数执行的时候宏任务先执行然后看看有没有微任务如果有就执行微任务然后宏任务结束在执行下一个微任务



#### 深浅拷贝

一个是值的拷贝一个是引用地址的拷贝
一个存在堆中一个存在栈中

json。parse（json.stringfin）
递归
lodash



#### 什么是点击劫持，

点击劫持就是一种诗篇手段，通过ifname的方式来镶入自己的网页并且设置透明然后设置按钮



#### diff算法的对比

diff复杂度是0（n3）
前端中我们很少跨成绩移动元素所以我么那只需要比较同一级别元素,所以就把复杂程度降到0（n）
算法首先会对新旧2课dom树进行深度优先的遍历，这样每个节点都有一个序号，每遍历一个节点时候，
我们就会拿这个节点和和新的节点进行比较，如果有差异我们就记录这个差异，
但是在进行列表元素的时候我们用key来比较



#### react中的key做了什么

追综与那些元素被修改，被添加，来识别组件



#### 调用this.setstate之后发生什么

1，在调用this.setstate之后，react会将传入的参数对象和当前的状态合并，然后触发调和过程
2，经过调和过程，react会一高效的方式根据新的状态构建react元素节点并且渲染ui界面
3，react得到元素树之后，react会自定计算新老树差异，然后根据差异进行最小化重渲染
4，在计算差异的时候，react能够精确知道那些位置发生变化并且知道如果改变，然后部分渲染



#### 多次触发setstate，那么render会执行几次

多个setstate会并成一次，因为setstate不会立刻改变数据，而是放到一个任务队列最终将多个setstate并且一次
改变页面

#### setstate是同步的还是异步的

在合成事件是异步的在某些事件是同部分而的

4，thsi.setstate之后react做了那些操作
shouldcomponentupdaye
componentwillupdate
render
componentdidmount

5，虚拟dom如果工作

当数据渲染变化的时候比较this.setstae的时候会引起组件重新渲染
收益差异就是用diff对老的dom和新的dom进行对比然后更该差异


1虚拟dom相当于js在真实dom加了一个缓存，刘哦能够diff算法避免没必要的渲染

用js对象结构来表示dom树的结构